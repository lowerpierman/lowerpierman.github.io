<!DOCTYPE html>


<html lang="zh-Hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="子标题面试时需删" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Y&amp;&amp;S</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/256love.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Y&amp;&amp;S</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['慢慢喜欢你！', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-软考复盘"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/26/%E8%BD%AF%E8%80%83%E5%A4%8D%E7%9B%98/"
    >title</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/26/%E8%BD%AF%E8%80%83%E5%A4%8D%E7%9B%98/" class="article-date">
  <time datetime="2022-05-26T07:07:54.000Z" itemprop="datePublished">2022-05-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一、上午题1"><a href="#一、上午题1" class="headerlink" title="一、上午题1"></a>一、上午题1</h3><p>​		概述：上午题总体考的还是比较常规，没有偏题怪题，都是408的基础知识，可能对一些计算机网络安全的常识掌握的还是不够。计算机体系结构考的是基础知识，还有没见过的比如DRAM和SRAM、中断处理时用堆栈来存储当前状态速率比较快；网络安全考的是DDOS和病毒的区别，在防火墙出口使用ACL可以防止SQL渗透；软工导论考的是面向对象分析方法，设计模式，螺旋模型等等；数据结构是树、图、关键路径、冒泡排序等排序算法的概念；计算机网络考了安全文件传输协议SFTP；操作系统考了树型目录的相对绝对路径、磁盘调度等等。</p>
<h1 id="二、下午题"><a href="#二、下午题" class="headerlink" title="二、下午题"></a>二、下午题</h1><p>​		概述：下午题比较简单，DFD、数据库以及类图用例图都考的相当简单，算法题给出了最优子结构的关键词，java题没有考继承和实现，考了一个设计模式。	</p>
<p>​	<br>​	</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E8%80%83/" rel="tag">软考</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-软考知识点Markdown版本"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/26/%E8%BD%AF%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9Markdown%E7%89%88%E6%9C%AC/"
    >title</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/26/%E8%BD%AF%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9Markdown%E7%89%88%E6%9C%AC/" class="article-date">
  <time datetime="2022-05-26T07:07:54.000Z" itemprop="datePublished">2022-05-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一、计算机组成"><a href="#一、计算机组成" class="headerlink" title="一、计算机组成"></a>一、计算机组成</h1><h2 id="1-二进制运算："><a href="#1-二进制运算：" class="headerlink" title="1.二进制运算："></a>1.二进制运算：</h2><p>​	原码常常用作加法<br>​	移码常常用作浮点数计算与表示</p>
<h2 id="2-校验码"><a href="#2-校验码" class="headerlink" title="2.校验码"></a>2.校验码</h2><p>​	奇偶校验码：加k个校验码后 1的位数达到奇数，就是奇校验 反之亦然<br>​	海明码：2^r&gt;&#x3D;1+k+r<br>​	CRC：CRC-n 校验码为n位</p>
<h2 id="3-浮点数运算与常识"><a href="#3-浮点数运算与常识" class="headerlink" title="3.浮点数运算与常识"></a>3.浮点数运算与常识</h2><h3 id="运算过程"><a href="#运算过程" class="headerlink" title="运算过程"></a>运算过程</h3><p>​	1.对阶，对阶时小向大转换，转换时尾数右移<br>​			2.求和<br>​			3.规格化<br>​			4.舍入与溢出判断</p>
<h3 id="什么是阶，什么是尾数"><a href="#什么是阶，什么是尾数" class="headerlink" title="什么是阶，什么是尾数"></a>什么是阶，什么是尾数</h3><h2 id="4-CPU"><a href="#4-CPU" class="headerlink" title="4.CPU"></a>4.CPU</h2><p>​	CPU分为控制器和运算器两部分<br>​	控制器包含程序计数器（PC），IR（指令寄存器），指令译码器（考的少）–》控制器的基本功能是发出指令，使机器有序执行<br>​	运算器包含算术逻辑运算单元（ALU），累加器（ACC），标志寄存器，寄存器组</p>
<h2 id="5-常考所需芯片数题目，需谨慎计算"><a href="#5-常考所需芯片数题目，需谨慎计算" class="headerlink" title="5.常考所需芯片数题目，需谨慎计算"></a>5.常考所需芯片数题目，需谨慎计算</h2><h2 id="6-CaChe命中率，存取周期"><a href="#6-CaChe命中率，存取周期" class="headerlink" title="6.CaChe命中率，存取周期"></a>6.CaChe命中率，存取周期</h2><p>​	注意根据条件列等式</p>
<h2 id="7-Cache全部由硬件实现，分为：直接相连，全相连，组相连。Cache由存储体、地址映像和替换机构组成，其中替换机构命中率最高的算法为LRU（最近最久未使用）"><a href="#7-Cache全部由硬件实现，分为：直接相连，全相连，组相连。Cache由存储体、地址映像和替换机构组成，其中替换机构命中率最高的算法为LRU（最近最久未使用）" class="headerlink" title="7.Cache全部由硬件实现，分为：直接相连，全相连，组相连。Cache由存储体、地址映像和替换机构组成，其中替换机构命中率最高的算法为LRU（最近最久未使用）"></a>7.Cache全部由硬件实现，分为：直接相连，全相连，组相连。Cache由存储体、地址映像和替换机构组成，其中替换机构命中率最高的算法为LRU（最近最久未使用）</h2><h2 id="8-Cache的地址位数由其容量决定，其容量的指数即为位数，给出在主存中的16位地址，低十四位为Cache地址。剩余位数为主存块号"><a href="#8-Cache的地址位数由其容量决定，其容量的指数即为位数，给出在主存中的16位地址，低十四位为Cache地址。剩余位数为主存块号" class="headerlink" title="8.Cache的地址位数由其容量决定，其容量的指数即为位数，给出在主存中的16位地址，低十四位为Cache地址。剩余位数为主存块号"></a>8.Cache的地址位数由其容量决定，其容量的指数即为位数，给出在主存中的16位地址，低十四位为Cache地址。剩余位数为主存块号</h2><p>​		若Cache为全相连映射，则先分析主存块号、块内地址位数，在分析主存块号对应的Cache块号</p>
<h2 id="9-ROM只读包括Flash-RAM随机"><a href="#9-ROM只读包括Flash-RAM随机" class="headerlink" title="9.ROM只读包括Flash RAM随机"></a>9.ROM只读包括Flash RAM随机</h2><h2 id="10-设备管理：程序查询，中断，DMA，通道技术-DMA通过建立主存与外部设备之间的数据通路节省了CPU"><a href="#10-设备管理：程序查询，中断，DMA，通道技术-DMA通过建立主存与外部设备之间的数据通路节省了CPU" class="headerlink" title="10.设备管理：程序查询，中断，DMA，通道技术 DMA通过建立主存与外部设备之间的数据通路节省了CPU"></a>10.设备管理：程序查询，中断，DMA，通道技术 DMA通过建立主存与外部设备之间的数据通路节省了CPU</h2><h2 id="11-内存地址和I-x2F-o地址-的地址代码不同"><a href="#11-内存地址和I-x2F-o地址-的地址代码不同" class="headerlink" title="11. 内存地址和I&#x2F;o地址 的地址代码不同"></a>11. 内存地址和I&#x2F;o地址 的地址代码不同</h2><h2 id="12-CISC和RISC的区别"><a href="#12-CISC和RISC的区别" class="headerlink" title="12.CISC和RISC的区别"></a>12.CISC和RISC的区别</h2><p>​	CISC 大量指令，少量通用寄存器，微程序控制<br>​	RISC 很少指令，大量通用寄存器，直接控制</p>
<h2 id="13-流水线的相关概念，不再重复"><a href="#13-流水线的相关概念，不再重复" class="headerlink" title="13.流水线的相关概念，不再重复"></a>13.流水线的相关概念，不再重复</h2><h2 id="14-串并联的可靠度与失效率"><a href="#14-串并联的可靠度与失效率" class="headerlink" title="14.串并联的可靠度与失效率"></a>14.串并联的可靠度与失效率</h2><h1 id="二、数据结构与算法"><a href="#二、数据结构与算法" class="headerlink" title="二、数据结构与算法"></a>二、数据结构与算法</h1><h2 id="1-偏移量–分为按行和按列的偏移量计算"><a href="#1-偏移量–分为按行和按列的偏移量计算" class="headerlink" title="1.偏移量–分为按行和按列的偏移量计算"></a>1.偏移量–分为按行和按列的偏移量计算</h2><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h2><p>​		循环队列中元素应当为：rear&gt;front,ele&#x3D;rear-front rear&lt;front,ele&#x3D;(rear-front+M)&#x2F;M</p>
<h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><p>​		在字符串中，空格并不是空，只是一种取值受限的线性表<br>​		字符串的广度：第一子元素个数<br>​		深度：括号层数</p>
<h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><p>​		树的度：树节点中的子节点个数max<br>​		树的深度（高度）：从根到达叶子的边数+1<br>​		要复习哈夫曼树的构造<br>​		线索二叉树的结构（分为先序、中序、后序）<br>​		树如何转二叉树 所有兄弟变孩子</p>
<h2 id="5-图"><a href="#5-图" class="headerlink" title="5.图"></a>5.图</h2><p>​		连通图指无向图<br>​		强联通图指有向图<br>​		生成树是无向图的极小联通子图<br>​		最小生成树是无向图中权值之和最小的生成树<br>​		AOE图可以估算工期<br>​		关键路径是指最长路径<br>​		无向连通图最少有n-1条边<br>​		邻接表、邻接矩阵<br>​		连通图的广度优先和深度优先生成树</p>
<h2 id="6-查找方法"><a href="#6-查找方法" class="headerlink" title="6.查找方法"></a>6.查找方法</h2><p>​		顺序查找、二分（折半）查找、哈希查找<br>​		其中哈希查找时如果使用hash函数计算得到的数组下标重复，使用线性探测法或者伪随机数法寻找数组下标，线性探测即放入n+1位置，伪随机数为换hash函数</p>
<h2 id="7-排序方法"><a href="#7-排序方法" class="headerlink" title="7.排序方法"></a>7.排序方法</h2><p>​		冒泡排序、快速排序、简单选择排序、直接插入排序、归并排序、希尔排序、堆排序、基数排序<br>​		其中，直接插入排序、冒泡排序、归并排序、基数排序是稳定的，<br>​		时间复杂度为O(n^2)的有直接插入、简单选择、冒泡排序，快速排序、归并排序、堆排序均为(Onlgn)<br>​		空间复杂度除快排（Onlgn）和归并基数其他均为O（1）</p>
<h1 id="三、设计模式专栏"><a href="#三、设计模式专栏" class="headerlink" title="三、设计模式专栏"></a>三、设计模式专栏</h1><p>​	创建型	工厂、抽象工厂、单例、建造者、原型<br>​	结构型  代理、享元、桥接器、适配器、装饰、外观、组合<br>​	行为型	某某者大部分是行为型（观察者、中介者、访问者、模板方法、策略、命令、职责链、状态、迭代器、备忘录、解释器）<br>​	创建型  用于描述怎样创建对象，目的是将接口与对象分离；<br>​	结构型	用于描述将类或对象按照某种布局组成更复杂的对象；<br>​	行为型用于描述如何将类或对象之间进行协作，使其完成单个类无法完成的任务，并为各个类或对象分配职责。</p>
<h1 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h1><p>​	进程管理</p>
<h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h2><p>​		运行、就绪、阻塞<br>​		运行、活跃就绪、活跃阻塞、静态就绪、静态阻塞</p>
<h2 id="2-PV操作"><a href="#2-PV操作" class="headerlink" title="2.PV操作"></a>2.PV操作</h2><p>​		P申请资源、V释放资源</p>
<h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h2><p>​		互斥资源<br>​		死锁产生的条件：互斥、请求和保持。不剥夺、环路等待<br>​		解决死锁问题：死锁预防：破坏四个条件<br>​					  死锁避免：银行家算法<br>​					  死锁解除<br>​	存储管理</p>
<h2 id="4-存储分区管理技术"><a href="#4-存储分区管理技术" class="headerlink" title="4.存储分区管理技术"></a>4.存储分区管理技术</h2><p>​		固定分区、可变分区、可重定位分区</p>
<h2 id="5-可变分区的作业植入算法"><a href="#5-可变分区的作业植入算法" class="headerlink" title="5.可变分区的作业植入算法"></a>5.可变分区的作业植入算法</h2><p>​		最佳适应、最差适应、首次适应、循环首次适应</p>
<h2 id="6-分页式、分段式、段页式"><a href="#6-分页式、分段式、段页式" class="headerlink" title="6.分页式、分段式、段页式"></a>6.分页式、分段式、段页式</h2><p>​		分页和分段其中的页和段不必连续<br>​		页大小固定，段不固定</p>
<h2 id="7-缺页调度算法"><a href="#7-缺页调度算法" class="headerlink" title="7.缺页调度算法"></a>7.缺页调度算法</h2><p>​		FIFO、LRU、</p>
<h2 id="8-文件管理"><a href="#8-文件管理" class="headerlink" title="8.文件管理"></a>8.文件管理</h2><p>​		文件系统是指实现文件管理的一种软件<br>​		文件系统实现了对文件的按名存取<br>​		文件的物理结构：顺序、链接、索引-》连续。。串联。。索引<br>​		树型目录</p>
<h2 id="9-作业调度算法"><a href="#9-作业调度算法" class="headerlink" title="9.作业调度算法"></a>9.作业调度算法</h2><p>​		先来先服务、最短作业优先、最高响应比优先</p>
<h2 id="10-磁盘调度算法"><a href="#10-磁盘调度算法" class="headerlink" title="10.磁盘调度算法"></a>10.磁盘调度算法</h2><h2 id="11补充"><a href="#11补充" class="headerlink" title="11补充"></a>11补充</h2><p>​		Unix把输入输出设备看做一种特殊的文件</p>
<h1 id="五、编译原理与程序语言"><a href="#五、编译原理与程序语言" class="headerlink" title="五、编译原理与程序语言"></a>五、编译原理与程序语言</h1><h2 id="1-自动机、文法"><a href="#1-自动机、文法" class="headerlink" title="1.自动机、文法"></a>1.自动机、文法</h2><h2 id="2-解释型语言：Python"><a href="#2-解释型语言：Python" class="headerlink" title="2.解释型语言：Python"></a>2.解释型语言：Python</h2><p>​		编译型语言：java、cC++<br>​		函数型：Lisp</p>
<h2 id="3-语法语义词法错误"><a href="#3-语法语义词法错误" class="headerlink" title="3.语法语义词法错误"></a>3.语法语义词法错误</h2><h1 id="六、数据库知识"><a href="#六、数据库知识" class="headerlink" title="六、数据库知识"></a>六、数据库知识</h1><h2 id="1-数据库模型"><a href="#1-数据库模型" class="headerlink" title="1.数据库模型"></a>1.数据库模型</h2><p>​		外模式、模式、内模式	外模式&#x2F;模式有多个-》逻辑独立	模式&#x2F;内模式只有一个-》物理独立<br>​		外模式：视图等；模式：物理数据库；内模式：真正的存储</p>
<h2 id="2-关系运算：投影、选择、笛卡尔积、差、交、并、连接（自然、非自然外）、除"><a href="#2-关系运算：投影、选择、笛卡尔积、差、交、并、连接（自然、非自然外）、除" class="headerlink" title="2.关系运算：投影、选择、笛卡尔积、差、交、并、连接（自然、非自然外）、除"></a>2.关系运算：投影、选择、笛卡尔积、差、交、并、连接（自然、非自然外）、除</h2><h2 id="3-并发操作的错误"><a href="#3-并发操作的错误" class="headerlink" title="3.并发操作的错误"></a>3.并发操作的错误</h2><p>​		丢失修改、不可重复读、读脏数据</p>
<h2 id="4-范式、函数依赖、规范化"><a href="#4-范式、函数依赖、规范化" class="headerlink" title="4.范式、函数依赖、规范化"></a>4.范式、函数依赖、规范化</h2><p>​		1NF-》2NF-》3NF-》BCNF<br>​		1-2：满足消除部分函数依赖<br>​		2-3：满足消除传递函数依赖<br>​		3-BC消除主属性之间的传递函数依赖<br>​		规范化：使用模式分解消除函数依赖<br>​		两种方法<br>​		1.表格法</p>
<pre><code>    2.公式
        R1∩R2-&gt;(R1-R2) R1∩R2-&gt;(R2-R1)是否正确？
</code></pre>
<h1 id="七、计算机网络"><a href="#七、计算机网络" class="headerlink" title="七、计算机网络"></a>七、计算机网络</h1><h2 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1.TCP"></a>1.TCP</h2><p>​		应用层协议：FTP、TFTP、SMTP、Telent、SNMP、DNS、BGP	<br>​		传输层：TCP、UDO<br>​		网络层：IP、ARP、RARP、ICMP</p>
<h1 id="八、多媒体知识"><a href="#八、多媒体知识" class="headerlink" title="八、多媒体知识"></a>八、多媒体知识</h1><h2 id="1-常见声音文件"><a href="#1-常见声音文件" class="headerlink" title="1.常见声音文件"></a>1.常见声音文件</h2><p>​		WAV、MOD、MPEG、RA、RMI、VOC</p>
<h2 id="2-位图和矢图"><a href="#2-位图和矢图" class="headerlink" title="2.位图和矢图"></a>2.位图和矢图</h2><p>​		相比位图空间更大，显示速度更快</p>
<h1 id="九、软件工程导论"><a href="#九、软件工程导论" class="headerlink" title="九、软件工程导论"></a>九、软件工程导论</h1><h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1.模型"></a>1.模型</h2><p>​		瀑布、增量、原型、快速原型、喷泉、螺旋、V</p>
<h2 id="2-软件估算模型"><a href="#2-软件估算模型" class="headerlink" title="2.软件估算模型"></a>2.软件估算模型</h2><p>​		IBM、patnam、COCOMO	其中IBM和COCOMO为静态，patnam为动态</p>
<h2 id="3-鱼骨图、甘特图"><a href="#3-鱼骨图、甘特图" class="headerlink" title="3.鱼骨图、甘特图"></a>3.鱼骨图、甘特图</h2><p>​		鱼骨图适用于展现软件的关键部分，甘特图适用于动态展示项目进度</p>
<h2 id="4-开发方法"><a href="#4-开发方法" class="headerlink" title="4.开发方法"></a>4.开发方法</h2><p>​		面向结构（数据流） 结构化开发<br>​		面向数据结构 Jackson、warnier<br>​		面向对象 UML、Booch</p>
<h2 id="5-软件测试"><a href="#5-软件测试" class="headerlink" title="5.软件测试"></a>5.软件测试</h2><p>​		白盒：路径覆盖、判定覆盖、语句覆盖<br>​		黑盒..<br>​		代码审查</p>
<h2 id="6-运行维护"><a href="#6-运行维护" class="headerlink" title="6.运行维护"></a>6.运行维护</h2><p>​		维护：改正、适应、完善、预防 其中完善工作量最大</p>
<h2 id="7-MCcabe、可靠性、失效率"><a href="#7-MCcabe、可靠性、失效率" class="headerlink" title="7.MCcabe、可靠性、失效率"></a>7.MCcabe、可靠性、失效率</h2><h2 id="8-CMM"><a href="#8-CMM" class="headerlink" title="8.CMM"></a>8.CMM</h2><h1 id="九、UML、设计模式"><a href="#九、UML、设计模式" class="headerlink" title="九、UML、设计模式"></a>九、UML、设计模式</h1><h2 id="1-UML的关系"><a href="#1-UML的关系" class="headerlink" title="1.UML的关系"></a>1.UML的关系</h2><p>​		依赖	虚线<br>​		组合、聚合	实现+菱形的实心或者空心<br>​		关联	实线<br>​		泛化	三角空心箭头</p>
<h2 id="2-设计模式详解"><a href="#2-设计模式详解" class="headerlink" title="2.设计模式详解"></a>2.设计模式详解</h2><p>​		创建型：工厂</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E8%80%83/" rel="tag">软考</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-面试学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/26/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0/"
    >title</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/26/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-05-26T07:07:54.000Z" itemprop="datePublished">2022-05-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>java面试学习<br>    1.StringBuffer和StringBuilder的区别<br>        StringBuilder线程安全，但效率更低<br>        String是final修饰的，内容不可改变，这俩都可以<br>    2.HashMap和HashTable<br>        HashMap是HashTable的轻量级实现，但HashTable线程安全，因为HashTable对全部内部操作都加了Synchronized同步锁。<br>        HashTable不允许键值为空，HashMap可以	 	<br>        HashMap底层是由数组加链表加红黑树实现的，在put时需要使用gethash获取要存入的数组下标 如hash%长度，得到的就是数组下标<br>        ConCurrentHashMap 使用分段所segment提高效率，将Map分为多个段去加锁处理。</p>
<pre><code>3.Hash方法：按位、加法、乘法、除法
4.实现线程通信的方法：管道、FIFO、信号、信号量
5.实现线程的方法：继承Thread，实现Runnable接口	new对象后调用start方法
6.线程和进程的区别	
    线程相比进程更轻量，一个进程可以包含多个线程。
7.tomcat和Apache的区别
</code></pre>
<h5 id="3-接口和抽象类区别"><a href="#3-接口和抽象类区别" class="headerlink" title="3.接口和抽象类区别"></a>3.接口和抽象类区别</h5><p>（1）抽象类中可以有非抽象方法并且方法可以实现；而接口中只能是抽象方法且不能实现。<br>        （2）抽象类只能被单继承（extends）；接口可以被多继承(implements)。<br>        （3）抽象类修饰符可以是public，protected以及默认类型；接口只能是public。<br>        （4）抽象类可以有构造器；接口没有。<br>        （5）抽象类在速度上比接口更快。</p>
<h5 id="4-Object有哪些方法？"><a href="#4-Object有哪些方法？" class="headerlink" title="4.Object有哪些方法？"></a>4.Object有哪些方法？</h5><p>1.对象浅复制的clone方法。2.获得运行时类型的getclass方法</p>
<p>3.哈希查找的hashcode方法。4.wait、notify方法</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-java反编译工具推荐 - jd-gui"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/06/01/java%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%20-%20jd-gui/"
    >java反编译工具推荐 - jd-gui</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/06/01/java%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%20-%20jd-gui/" class="article-date">
  <time datetime="2021-06-01T13:06:09.000Z" itemprop="datePublished">2021-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>一、工具简介 </p>
<p>官网：<a target="_blank" rel="noopener" href="http://java-decompiler.github.io/">http://java-decompiler.github.io</a> </p>
<p>&#x2F;&#x2F;可以直接下载 官网简介说这款工具有图形化界面，支持java5之后的版本代码还原</p>
<p> 二、工具使用 </p>
<p>支持linux、win使用，也支持作为eclipse插件使用 界面：<img src="https://img-blog.csdnimg.cn/20210420202007241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p>需要反编译的jar包直接通过file-&gt;open file打开即可</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-今天在同门帮助下掌握了AxMath和MixPath的使用，感觉很好用，很适合排版"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/06/01/%E4%BB%8A%E5%A4%A9%E5%9C%A8%E5%90%8C%E9%97%A8%E5%B8%AE%E5%8A%A9%E4%B8%8B%E6%8E%8C%E6%8F%A1%E4%BA%86AxMath%E5%92%8CMixPath%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%84%9F%E8%A7%89%E5%BE%88%E5%A5%BD%E7%94%A8%EF%BC%8C%E5%BE%88%E9%80%82%E5%90%88%E6%8E%92%E7%89%88/"
    >今天在同门帮助下掌握了AxMath和MixPath的使用，感觉很好用，很适合排版</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/06/01/%E4%BB%8A%E5%A4%A9%E5%9C%A8%E5%90%8C%E9%97%A8%E5%B8%AE%E5%8A%A9%E4%B8%8B%E6%8E%8C%E6%8F%A1%E4%BA%86AxMath%E5%92%8CMixPath%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%84%9F%E8%A7%89%E5%BE%88%E5%A5%BD%E7%94%A8%EF%BC%8C%E5%BE%88%E9%80%82%E5%90%88%E6%8E%92%E7%89%88/" class="article-date">
  <time datetime="2021-06-01T13:06:09.000Z" itemprop="datePublished">2021-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>AxMath 作为开源软件，方便数学公式的书写和排版。 下载地址：<a target="_blank" rel="noopener" href="https://gitee.com/yang-zwsx/adobe-pagemaker-.git">https://gitee.com/yang-zwsx/adobe-pagemaker-.git</a></p>
<p>Mixpath方便用于识别论文中的公式。 使用方法： 1.找到索要识别的公式截图<img src="https://img-blog.csdnimg.cn/2021040810130140.png" alt="在这里插入图片描述"> 2.Ctrl+Alt+M <img src="https://img-blog.csdnimg.cn/20210408101401569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 3.导入Latex代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\|x\|_&#123;&lt;!-- --&gt;p&#125;=\left(\sum_&#123;&lt;!-- --&gt;i&#125;\left|x_&#123;&lt;!-- --&gt;i&#125;\right|^&#123;&lt;!-- --&gt;p&#125;\right)^&#123;&lt;!-- --&gt;\frac&#123;&lt;!-- --&gt;1&#125;&#123;&lt;!-- --&gt;p&#125;&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图像预览如下： </p>
<pre><code>     ∥
</code></pre>
<p>​<br>         x</p>
<p>​<br>​<br>          ∥</p>
<p>​<br>          p</p>
<p>​<br>​<br>         &#x3D;</p>
<p>​<br>​<br>​<br>           (</p>
<p>​<br>​<br>            ∑</p>
<p>​<br>            i</p>
<p>​<br>​<br>​<br>​<br>             ∣</p>
<p>​<br>​<br>              x</p>
<p>​<br>              i</p>
<p>​<br>​<br>             ∣</p>
<p>​<br>​<br>            p</p>
<p>​<br>​<br>           )</p>
<p>​<br>​<br>​<br>           1</p>
<p>​<br>           p</p>
<p>​<br>​<br>​<br>​<br>         |x|<em>{p}&#x3D;\left(\sum</em>{i}\left|x_{i}\right|^{p}\right)^{\frac{1}{p}} </p>
<p>​<br>     ∥x∥p​&#x3D;(i∑​∣xi​∣p)p1​</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-层次分析法——解决购买篮球鞋的问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/06/01/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E8%B4%AD%E4%B9%B0%E7%AF%AE%E7%90%83%E9%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98/"
    >层次分析法——解决购买篮球鞋的问题4</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/06/01/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3%E8%B4%AD%E4%B9%B0%E7%AF%AE%E7%90%83%E9%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-06-01T13:06:09.000Z" itemprop="datePublished">2021-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>准则层：篮球鞋的选择 目标层：鞋的配置、价格、代言人名气、品牌信誉 方案层：耐克、安德玛、李宁 <img src="https://img-blog.csdnimg.cn/885c64a8d0ee48a9a1897a9540a49a9c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 特征值法求权重的结果为： 0.4933 0.2397 0.1629 0.1040 一致性指标CI&#x3D; 0.085305 一致性比例CR&#x3D; 0.095848 因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受! 一致性通过 配置判断矩阵 <img src="https://img-blog.csdnimg.cn/6e6224ab8d2b43bea154bff586ec251d.png" alt="在这里插入图片描述"> 特征值法求权重的结果为： 0.6250 0.2385 0.1365 一致性指标CI&#x3D; -0.3272 一致性比例CR&#x3D; -0.3677 因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受!</p>
<p><img src="https://img-blog.csdnimg.cn/c82e3ffe772a49d485ead0555c3c6dce.png" alt="在这里插入图片描述"> 特征值法求权重的结果为： 0.5278 0.3325 0.1396 一致性指标CI&#x3D; -0.3155 一致性比例CR&#x3D; -0.3544 因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受! <img src="https://img-blog.csdnimg.cn/16785c40028046dba46e80fe1c3c701d.png" alt="在这里插入图片描述"> 特征值法求权重的结果为： 0.730645 0.188394 0.080961 一致性指标CI&#x3D; -0.3117 一致性比例CR&#x3D; -0.3502 因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受! <img src="https://img-blog.csdnimg.cn/f00982e27a7c42f9906ac9bc9a72eed9.png" alt="在这里插入图片描述"> 特征值法求权重的结果为： 0.6370 0.2583 0.1047 一致性指标CI&#x3D; -0.3205 一致性比例CR&#x3D; -0.3601 因为CR&lt;0.10，所以该判断矩阵A的一致性可以接受!</p>
<p><img src="https://img-blog.csdnimg.cn/33be205957454785a065bec895cde0cb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 耐克得分:0.4933<strong>0.625+ 0.2397</strong>0.528+ 0.1629<strong>0.73+ 0.1040</strong>0.64&#x3D;0.62 安德玛得分:0.4933<strong>0.239+ 0.2397</strong>0.333+ 0.1629<strong>0.19+ 0.1040</strong>0.26&#x3D;0.256 李宁得分:0.4933<strong>0.137+ 0.2397</strong>0.14+ 0.1629<strong>0.08+ 0.1040</strong>0.1&#x3D;0.125</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BB%BA%E6%A8%A1/" rel="tag">建模</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-并发缺陷分类及详述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/06/01/%E5%B9%B6%E5%8F%91%E7%BC%BA%E9%99%B7%E5%88%86%E7%B1%BB%E5%8F%8A%E8%AF%A6%E8%BF%B0/"
    >并发缺陷分类及详述</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/06/01/%E5%B9%B6%E5%8F%91%E7%BC%BA%E9%99%B7%E5%88%86%E7%B1%BB%E5%8F%8A%E8%AF%A6%E8%BF%B0/" class="article-date">
  <time datetime="2021-06-01T13:06:09.000Z" itemprop="datePublished">2021-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在已开发的成熟的web服务器以及数据库管理系统 例如Mysql Apache中，通过统计这些应用历次进行并发缺陷修复时可以看到，大部分并发缺陷均为非死锁缺陷，有大概四分之一的缺陷为死锁缺陷</p>
<p>非死锁缺陷：违反原子性（atomicity violation）缺陷和错误顺序（order violation）缺陷</p>
<h2 id="违反原子性："><a href="#违反原子性：" class="headerlink" title="违反原子性："></a>违反原子性：</h2><ol>
<li><code>1``Thread``1::</code>1. <code>2``if``(thd-&amp;gt;proc_info)``&#123;&lt;!-- --&gt;</code>1. <code>3``...</code>1. <code>4 fputs(thd-&amp;gt;proc_info,``...);</code>1. <code>5``...</code>1. <code>6``&#125;</code>1. <code>7</code>1. <code>8``Thread``2::</code>1. <code>9 thd-&amp;gt;proc_info = NULL;</code><br><code>这个典型例子说明了在进程1和进程2并发执行的过程中，调用空指针pro_info 导致程序崩溃。</code></li>
</ol>
<p>根据Lu等人，更正式的违反原子性的定义是：“违反了多次内存访问中预期的可串行性（即代码段本意是原子的，但在执行中并没有强制实现原子性）”。</p>
<p>修复的方法：（加锁）</p>
<ol>
<li><code>1``pthread_mutex_t proc_info_lock = PTHREAD_MUTEX_INITIALIZER;</code>1. <code>2</code>1. <code>3``Thread``1::</code>1. <code>4 pthread_mutex_lock(&amp;amp;proc_info_lock);</code>1. <code>5``if``(thd-&amp;gt;proc_info)``&#123;&lt;!-- --&gt;</code>1. <code>6``...</code>1. <code>7 fputs(thd-&amp;gt;proc_info,``...);</code>1. <code>8``...</code>1. <code>9``&#125;</code>1. <code>10 pthread_mutex_unlock(&amp;amp;proc_info_lock);</code>1. <code>11</code>1. <code>12``Thread``2::</code>1. <code>13 pthread_mutex_lock(&amp;amp;proc_info_lock);</code>1. <code>14 thd-&amp;gt;proc_info = NULL;</code>1. <code>15 pthread_mutex_unlock(&amp;amp;proc_info_lock);</code></li>
</ol>
<h2 id="违反顺序缺陷："><a href="#违反顺序缺陷：" class="headerlink" title="违反顺序缺陷："></a>违反顺序缺陷：</h2><ol>
<li><code>Thread``1::</code>1. <code>void init()``&#123;&lt;!-- --&gt;</code>1. <code>...</code>1. <code> mThread = PR_CreateThread(mMain,``...);</code>1. <code>...</code>1. <code>&#125;</code>1. <li><code>Thread``2::</code>1. <code>void mMain(...)``&#123;&lt;!-- --&gt;</code>1. <code>...</code>1. <code> mState = mThread-&amp;gt;State;</code>1. <code>...</code>1. <code>&#125;</code><br><code>这个例子说明了当进程1和2并发执行时，由于在调用MThread之前可能还未初始化，导致程序出现问题。</code>违反顺序更正式的定义是：“两个内存访问的预期顺序被打破了（即A应该在B之前执行，但是实际运行中却不是这个顺序）”</li>
</ol>
<p>我们通过强制顺序来修复这种缺陷。</p>
<ol>
<li><code>pthread_mutex_t mtLock = PTHREAD_MUTEX_INITIALIZER;</code>1. <code>pthread_cond_t mtCond = PTHREAD_COND_INITIALIZER;</code>1. <code>int mtInit =``0;</code>1. <li><code>Thread``1::</code>1. <code>void init()``&#123;&lt;!-- --&gt;</code>1. <code>...</code>1. <code> mThread = PR_CreateThread(mMain,``...);</code>1. <li><code>// signal that the thread has been created...</code>1. <code> pthread_mutex_lock(&amp;amp;mtLock);</code>1. <code> mtInit =``1;</code>1. <code> pthread_cond_signal(&amp;amp;mtCond);</code>1. <code> pthread_mutex_unlock(&amp;amp;mtLock);</code>1. <code>...</code>1. <code>&#125;</code>1. <li><code>Thread``2::</code>1. <code>void mMain(...)``&#123;&lt;!-- --&gt;</code>1. <code>...</code>1. <code>// wait for the thread to be initialized...</code>1. <code> pthread_mutex_lock(&amp;amp;mtLock);</code>1. <code>while``(mtInit ==``0)</code>1. <code> pthread_cond_wait(&amp;amp;mtCond,``&amp;amp;mtLock);</code>1. <code> pthread_mutex_unlock(&amp;amp;mtLock);</code>1. <li><code> mState = mThread-&amp;gt;State;</code>1. <code>...</code>1. <code>&#125;</code><h3 id="非死锁缺陷：小结"><a href="#非死锁缺陷：小结" class="headerlink" title="非死锁缺陷：小结"></a>非死锁缺陷：小结</h3></li>
</ol>
<p>大部分（97%）的非死锁问题是违反原子性和违反顺序这两种。因此，程序员仔细研究这些错误模式，应该能够更好地避免它们。此外，随着更自动化的代码检查工具的发展，它们也应该关注这两种错误，因为开发中发现的非死锁问题大部分都是这两种。</p>
<p>然而，并不是所有的缺陷都像我们举的例子一样，这么容易修复。有些问题需要对应用程序的更深的了解，以及大量代码及数据结构的调整。</p>
<h2 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h2><p>除了上面提到的并发缺陷，死锁（deadlock）是一种在许多复杂并发系统中出现的经典问题。例如，当线程1持有锁L1，正在等待另外一个锁L2，而线程2持有锁L2，却在等待锁L1释放时，死锁就产生了。以下的代码片段就可能出现这种死锁：</p>
<ol>
<li><code>Thread``1:``Thread``2:</code>1. <code>lock(L1);``lock(L2);</code>1. <code>lock(L2);``lock(L1);</code></li>
</ol>
<h2 id="数据竞争（data-race）是指在非线程安全的情况下，多线程对同一个地址空间进行写操作。一般来说，我们都会通过线程同步方法来保证数据的安全，比如采用互斥量或者读写锁。但是由于某些笔误或者设计的缺陷，还是存在data-race的可能性的。"><a href="#数据竞争（data-race）是指在非线程安全的情况下，多线程对同一个地址空间进行写操作。一般来说，我们都会通过线程同步方法来保证数据的安全，比如采用互斥量或者读写锁。但是由于某些笔误或者设计的缺陷，还是存在data-race的可能性的。" class="headerlink" title="数据竞争（data race）是指在非线程安全的情况下，多线程对同一个地址空间进行写操作。一般来说，我们都会通过线程同步方法来保证数据的安全，比如采用互斥量或者读写锁。但是由于某些笔误或者设计的缺陷，还是存在data race的可能性的。"></a>数据竞争（data race）是指在非线程安全的情况下，多线程对同一个地址空间进行写操作。一般来说，我们都会通过线程同步方法来保证数据的安全，比如采用互斥量或者读写锁。但是由于某些笔误或者设计的缺陷，还是存在data race的可能性的。</h2><h2 id="若线程的类型状态发生改变，且没有与另外线程的其他操作同步，则会造成对象执行其类型状态中不允许的操作，从而产生并发类型状态缺陷。"><a href="#若线程的类型状态发生改变，且没有与另外线程的其他操作同步，则会造成对象执行其类型状态中不允许的操作，从而产生并发类型状态缺陷。" class="headerlink" title="若线程的类型状态发生改变，且没有与另外线程的其他操作同步，则会造成对象执行其类型状态中不允许的操作，从而产生并发类型状态缺陷。"></a>若线程的类型状态发生改变，且没有与另外线程的其他操作同步，则会造成对象执行其类型状态中不允许的操作，从而产生并发类型状态缺陷。</h2><h2 id="使用模型检测来进行并发缺陷检测的流程："><a href="#使用模型检测来进行并发缺陷检测的流程：" class="headerlink" title="使用模型检测来进行并发缺陷检测的流程："></a>使用模型检测来进行并发缺陷检测的流程：</h2><p><strong>模型检测是一种验证有限状态系统时序逻辑属性的形式化方法。首先将软件构造为状态机等抽象模型,然后使用模态&#x2F;时序逻辑公式等形式化的表达式来描述安全属性,最终对模型进行遍历以验证软件是否满足安全属性,从而判断是否存在缺陷。Verisoft[33]是基于程序执行信息提取的模型检测工具,通过调度程序执行,利用程序执行信息(堆、栈和寄存器等)构造状态转换图（Kripke图）,然后进行属性验证。此后,Verisoft,JPF[34]和SPIN[35]模型检测工具得到了广泛应用。模型检测可以检测到并发缺陷中：死锁，数据竞争，顺序性违背和原子性违背四种缺陷。</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-阅读Model Checking笔记手册 第一章 模型检测的介绍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/06/01/%E9%98%85%E8%AF%BBModel%20Checking%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%8C%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/"
    >阅读Model Checking笔记手册 第一章 模型检测的介绍</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/06/01/%E9%98%85%E8%AF%BBModel%20Checking%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%8C%20%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2021-06-01T13:06:09.000Z" itemprop="datePublished">2021-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一、模型检测的过程："><a href="#一、模型检测的过程：" class="headerlink" title="一、模型检测的过程："></a>一、模型检测的过程：</h2><p>Modeling 建模 将设计转换为模型检测工具可接受的形式。 Specification 规约 使用时序逻辑等方法描述设计所必须满足的特性或者说设计需要验证的性质。 但模型检查提供了检查设计模型是否满足给定性质的方法，但是无法确定给定性质是否涵盖了系统应该满足的所有属性。 Verification 验证 对于之前建模所建立的模型和规约所描述的性质进行自动验证，如果模型不符合性质则给出相应的反例路径。</p>
<p>对于程序的不可判定性，可以通过控制其有界性来得到一个有限状态的系统，使得程序具有判定性。（将无界系统划分为无穷个有界系统使程序具有可判定性）</p>
<p>模型检测方法：首先将要检验的系统转换为状态迁移图（即Kripke结构），规范被表示为时态逻辑公式，然后由模型检测器来决定</p>
<pre><code>    K
</code></pre>
<p>​<br>        ⊨</p>
<p>​<br>        φ</p>
<p>​<br>​<br>       K \models \varphi</p>
<p>​<br>    K⊨φ是否为真，若不为真则模型检测器输出一个反例，这也意味着传统的软件测试检查错误相比验证（证明错误不存在）更快。 模型检测研究过程中出现的两个最主要的问题： 1.由于状态空间爆炸提出的算法改进。 2.建模的扩展。将模型检查框架扩展到Kripke结构和时态逻辑之外。Kripke结构是各种通信有限状态机的自然表示。但对于无界迭代和递归、无界并发和分布、进程创建和重新配置、无界数据类型、实时和网络物理系统、概率计算、安全方面等，为了有效地抽象这些特征，我们需要将建模和规范框架扩展到克里普克结构和经典时态逻辑之外。一些扩展保持可判定性，通常通过构造有限状态抽象，这将建模挑战与算法挑战联系起来；另一些扩展牺牲了可判定性，但是保持了模型检查的能力，以便在系统设计过程的早期自动、系统地发现错误。</p>
<h2 id="二、模型检测的优势："><a href="#二、模型检测的优势：" class="headerlink" title="二、模型检测的优势："></a>二、模型检测的优势：</h2><p>1.验证的自动化，无需模型检测领域的专业人员辅助。 2.模型检测可以用于设计的各个阶段，既可以用于抽象的模型，也可以用于实现的代码。 3.适用于检验并发方面的错误。</p>
<p>模型检测相比于其他验证程序的方法最大的特点在于，它可以调试和分析现实世界中存在的所有可以建模为动态的状态转换系统的目标。</p>
<h2 id="三、模型检测研究过程中出现的两个最主要的问题"><a href="#三、模型检测研究过程中出现的两个最主要的问题" class="headerlink" title="三、模型检测研究过程中出现的两个最主要的问题"></a>三、模型检测研究过程中出现的两个最主要的问题</h2><p>模型检验研究的一个重要部分集中在处理状态空间爆炸的算法方法上，这些方法避免了显式构造完整的Kripke结构，之所以不构造完整的Kripke结构是因为由于每个状态表示给定的时间点下的全局系统状态，所以所有的状态本质上是待验证系统的内存快照（类似网站快照），因此，状态空间的大小与内存大小成指数关系。因此，即使对于相对较小的系统，也不可能直接计算和分析整个相应的Kripke结构。我们大致可以将这些方法分为三大类</p>
<p>第一类：对状态空间进行约简——用于模型检查的结构化方法利用了定义系统的语法表达式的结构。大型硬件和软件系统被模块化地描述，例如，子例程(过程和方法调用)用顺序结构来表示，交互并行硬件组件和软件进程(线程、参与者)用并发结构来表示。虽然状态空间可能是有限的，但它可以是非常大的，构造和探索代表整个状态空间的Kripke结构将牺牲任何优势，比如从研究系统的定义中可以获得的对称性。故而使用“扁平化”来对系统进行描述。诸如对称约简、动态状态空间探索、偏序约简、假设保证推理和参数验证等技术避免了盲目的扁平化，并以某种方式利用系统结构来获得更好的性能。</p>
<p>并发软件系统的搜索优化技术（第六章），并发软件系统的复杂性源于并发过程中大量可能的交错。所谓的偏序约简利用了这样一个事实，即来自不同进程的独立事件的顺序对计算结果并不重要。 组合推理(第12章)通过分治法的思想和复杂系统的模块化定义对系统部件的正确性证明推导到整体系统的正确性证明，这种方法从(通常更简单的)系统部件的正确性证明中获得了整体系统正确性的证明。 通常，关于系统部件的证明不是完全独立的，但是，关于系统某个部件的证明可能会对其他部件的行为做出假设，这被称为“假定-保证推理”。</p>
<p>第二类：对状态空间采用符号编码的方法进行描述减少了内存空间的占用——符号方法通过符号逻辑中的表达式表示Kripke结构的状态集和转换关系，而不是通过状态或转换的显式枚举。符号编码——无论是通过二进制决策图（BDD）、命题公式，还是无量词的一阶约束——都可以极大地压缩表示状态集的数据结构，如果能够有效地执行必要的操作，在验证工具的实际性能上有数量级的改进。第7章和第8章致力于使用二进制决策图(bdd)进行模型检查。作为布尔函数的一种数据结构，二进制决策图比布尔公式和电路的优点是可以在常数时间内检查可满足性和等价性。当在第1.2.3节中讨论的CTL定点算法中使用时，基于二进制决策图的状态集编码在实践中常常能实现数据结构的指数级减少。在20世纪90年代，基于二进制决策图的模型检查获得了显著的性能改进，这对硬件行业中模型检查的成功至关重要。 虽然最初术语“符号模型检查”就是指代基于二进制决策图的模型检查，但最近其他状态集和路径的符号编码(布尔和更通常的情况下)已被证明在不同的情况下是有用的。第9章和第10章介绍了基于SAT的模型检查，一种LTL的符号模型检查方法。正如在第1.2.4节中所讨论的，LTL有套索（缰绳）状的反例，并且布尔公式可以用来根据命题逻辑来指定反例存在的约束条件。通过求解这些约束条件，布尔可满足求解器可以计算出反例的组成部分，或证明反例的不存在性。这样，基于SAT的模型检测可以从SAT解决的最新改进中获益。在最初的公式中，基于SAT的模型检查是不完整的，因为它只能找到有界长度的反例路径(“有界模型检测”)，第十章讨论了实现完整性的方法。如今，基于SAT的模型检查是硬件行业的标准工具，也用于位精确的软件模型检查。为了表达非布尔域上的状态，布尔逻辑可以被无量词一阶逻辑的可判定理论取代，即SAT模理论(SMT)。SMT求解器(第11章)是一种强大的决策程序，它发展迅速，并成为许多现代软件模型检查器的基础。第26和31章讨论了布尔域和非布尔域模型检查的一般定点算法。</p>
<p>第三类：抽象(第13-15章)是一种更激进的压缩状态空间的方法。抽象将克里普克结构中的K简化为更小的同态图像</p>
<pre><code>     K
</code></pre>
<p>​<br>         ^</p>
<p>​<br>​<br>​<br>       \hat{K}</p>
<p>​<br>    K^——抽象模型——它保留了原始结构的某些属性，可以更有效地进行分析。换句话说，抽象模型是系统的有原则的过度逼近。例如，原始结构和抽象结构之间的模拟关系的存在保证了原始结构上的树形反例不会在抽象中丢失，<strong>尽管可能存在仅出现在抽象中的“虚假反例”</strong>。形式上，如果</p>
<p>​<br>​<br>​<br>​<br>         K</p>
<p>​<br>         ^</p>
<p>​<br>​<br>​<br>       \hat{K}</p>
<p>​<br>    K^模拟K，那么对于整个ACTL*对应ϕ，</p>
<p>​<br>​<br>​<br>​<br>         K</p>
<p>​<br>         ^</p>
<p>​<br>​<br>        ⊨</p>
<p>​<br>        φ</p>
<p>​<br>​<br>       \hat{K} \models \varphi</p>
<p>​<br>    K^⊨φ那么</p>
<p>​<br>​<br>​<br>        K</p>
<p>​<br>        ⊨</p>
<p>​<br>        φ</p>
<p>​<br>​<br>       K \models \varphi</p>
<p>​<br>    K⊨φ，但反过来这些都不成立。原始结构和抽象结构之间的其他关系保留了不同的规范逻辑。 许多现代模型检查器的一个关键要素是反例引导的抽象精化——一种通过构建精度不断提高的迭代抽象模型来验证系统的算法方法。为此，通过向抽象模型添加先前从系统描述中忽略的细节来分析和消除虚假反例，以便改进抽象，直到发现真实的反例(即缺陷)，或者不再出现虚假反例并且系统得到验证；参见图6。第14章讨论了内插，一种在路径内定位证明中的断言的聚合逻辑方法，可用于识别和消除虚假反例。第15章介绍了基于谓词抽象的软件验证的现代介绍，其中抽象模型的状态使用程序计数器和程序变量上的约束(“谓词”)来描述。 <img src="https://img-blog.csdnimg.cn/20210510100816736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>模型检测研究的另一个重要部分是建模的扩展。虽然待验证系统可以使用克里普克结构建模的广泛的系统，但是对于一些关键的应用，基本的状态转移系统模型必须用额外的特征来扩充。对于建模软件来说，有限状态转移系统有四种典型的扩展情景，它们对于建模某些重要的系统类别是必不可少的。</p>
<ol>
<li>安全协议的模型检测 安全协议为形式化方法提供了一个完美的应用领域:它们通常很小，但很难被正确处理，它们的正确性至关重要。然而，任何安全协议的方法都必须处理非有限状态的概念，如随机数和密钥、加密和解密以及未知的攻击者。1. 图形游戏 图形游戏是具有多个参与者的状态转移系统的扩展。在每个状态中，一个或多个参与者选择动作，这些动作一起决定系统的下一个状态。需要图形游戏来为具有多个组件、流程、参与者或代理的系统建模，这些组件、流程、参与者或代理具有不同的、有时是冲突的目标。即使系统是单一的，它的环境有时也必须独立考虑，就像两人游戏中的对手一样。1. 概率系统 概率系统是状态转移系统，例如离散时间马尔可夫链或马尔可夫决策过程，其中根据概率分布从某些状态选择下一个状态。概率系统可以模拟不确定性。1. 实时和混合系统 实时和混合系统是具有<strong>连续组件</strong>的<strong>离散</strong>状态转移系统的扩展。在实时系统中，连续组件是时钟，它测量和约束状态转换可能发生的时间；具有这种时钟和时钟约束的有限自动机的扩展称为“时间自动机”；在混合系统中，有限自动机可以用更常见的连续变量来扩展，例如，表示物理系统的位置或温度。虽然时间自动机已经成为连续时间状态转换系统的标准模型，但是需要混合自动机来建模由硬件和软件控制的物理系统(“网络物理系统”)。时间和混合自动机的某些特性仍然是可判定的；在其他情况下，我们有模型检查的半算法，它计算验证问题的答案，但在某些情况下可能形成死循环。<h2 id="四、模型检测的未来"><a href="#四、模型检测的未来" class="headerlink" title="四、模型检测的未来"></a>四、模型检测的未来</h2></li>
</ol>
<p>基于硬件和软件的系统越来越普遍，越来越复杂。我们看到从多核处理器到数据中心、传感器网络和云，它们的并发级别不断提高。此外，基于硬件和软件的系统越来越多地部署在安全关键的情况下，从控制和连接心脏的起搏器到飞机的物理控制系统。随着系统复杂性和关键性的急剧增长，对有效验证技术的需求也在增长。换句话说，模型检测的机会比比皆是。我们期望相应的研究工作继续在可伸缩性和建模挑战方面取得进展，将更大和更多样的验证问题纳入模型检测技术的范围。模型检查已经被集成到硬件的设计过程中。在不久的将来，我们预计模型检查将在软件开发实践中取得类似的进展，特别是在容易出错的以控制为中心(而不是以数据为中心)的软件领域，包括系统软件(内核、调度程序、设备驱动程序、内存和通信协议等)、分布式算法和并发数据结构、以及软件定义网络、信息物理系统—-（与物联网相似的概念，与物联网相比，它还强调控制）等。</p>
<p>其次，虽然在过去，新技术主要是由性能(摩尔定律)和功能(新特性)的提高驱动的，但我们认为，在未来，系统的正确性、可靠性、安全性和整体健壮性将发挥越来越大的作用，也是软件和硬件产品的一个主要区分。我们已经在现代软件系统研究中看到了这种趋势，在现代软件系统研究中，性能曾经是主要的标准，但正确性最近已经在编译器，操作系统和分布式系统研究中占据了中心位置。这一趋势将进一步增加模型检测等形式化验证技术的影响。</p>
<p>我们认为还有第三个，甚至更基本的原因，模型检测的越发重要的原因是状态迁移系统的出现，它是计算机控制的动态系统设计和研究的通用模型。状态迁移系统是连续动力系统的离散模拟。随着数字技术的兴起，基于状态迁移系统(或“离散事件系统”)的模型在系统工程中变得普遍存在。它们同样适用于人类设计的形式化的动态的包括各种图表、图表和组织中发生的工作流、交互和自适应结构的规则，以及定义物理世界中发生的连续过程的离散抽象。模型检查——作为分析状态迁移系统的中心范例——这仅仅是它在广泛的不同领域应用的开始，从工程（应用）到科学、商业、法律等等领域。</p>
<p>除了介绍模型检测的未来发展前景之外，还介绍了模型检测当前热点研究的两个方向，以及两个潜在的模型检测新应用领域。</p>
<ol>
<li>将模型检测的应用从简单的验证性质转向综合（自动构架符合要求的系统） 在第一个趋势中，当前的许多研究致力于从验证走向综合。验证是检测给定系统是否满足给定规范的任务；综合是构建满足给定规格的系统的任务。虽然全自动功能合成仅在受限的情况下才是有效且实用的，例如高级语言编程，或者对给定的构建块进行电路合成，但是一般的合成任务在需要细化或完成给定的部分系统描述以满足某些属性的设置方面已经取得了很大的进展。通常合成的属性是非功能性的；例如，并发的顺序程序可以自动配备同步结构，如锁或原子区域，以使程序在不改变其顺序语义的情况下安全地并行执行。更一般地说，“计算机辅助编程”的目标是将程序员从繁琐但容易出错的实现细节中解放出来，这样他们就可以专注于设计的功能，同时自动满足设计安全和容错方面的其他要求。反应式(或顺序式)综合是指满足给定时间规范的状态迁移系统的综合，该规范约束期望系统的输入&#x2F;输出行为；这个问题在数理逻辑、控制理论、博弈论和反应式编程中有平行的历史，并在第二章中详细讨论。最近，大量的工作致力于模板和语法引导的合成方法，并在合成中使用归纳以及学习技术。1. List item</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%91%E7%A0%94/" rel="tag">科研</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-阅读Model Checking笔记手册 第三章 模型验证"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/06/01/%E9%98%85%E8%AF%BBModel%20Checking%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%8C%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/"
    >阅读Model Checking笔记手册 第三章 模型验证</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/06/01/%E9%98%85%E8%AF%BBModel%20Checking%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%8C%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/" class="article-date">
  <time datetime="2021-06-01T13:06:09.000Z" itemprop="datePublished">2021-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li>一个模型，从广义上来说，可以被认为是一个系统“在纸上”的描述，或者是一个“虚拟”系统。这与“真实”系统形成对比，后者可以被认为是一个物理组件例如一辆汽车、一个医疗设备、一个Java程序或一个股票市场。将Java程序或股票市场描述为“实体”可能看起来很奇怪；然而，抛开哲学上的考虑，大多数人会同意这些系统是具体而真实的，足以直接影响我们的生活。模型也影响我们的生活，但是是以一种更间接的方式，正如我们下面讨论的那样。 -  模型的类型由其用途定义。现有系统的模型通常被简称为“模型”，而尚未建立的系统模型可以被称为“规范”或“设计”。有些模型是用开放解释的非形式化符号编写的，而另一些是用具有数学语义的语言编写的，被称为“形式化模型”。最重要的是，模型很少完整刻画一个系统，因为大多数系统的绝对规模和复杂性使得这成为一项不可能的任务。因此，模型通常只关注系统的“相关”部分和或系统的特定方面。例如，同时涉及硬件(HW)和软件(SW)的系统模型可能只关注软件部分；或者一个模型只关注通信系统的逻辑方面，例如通信协议，而忽略其他方面，例如性能(例如吞吐量、延迟)或能耗。 -  一直以来模型对于我们的生活都至关重要。人类以及许多其他生物需要在他们的大脑中形成外部世界如何运行起来的内部特征，这些可以看作模型。而更接近本书的重点的是工程和技术严重依赖数学模型。事实上，设计和构建系统的任务与各种建模任务密切相关。规范模型用于在不同的工程团队之间交流系统的目标和需求。建立详细的设计模型是为了在系统构建之前对其行为进行评估。这对于避免建造有缺陷的系统的成本和危险是至关重要的。在一个系统建立后，为了操作和维护系统，校准和调整系统，监控异常行为，并最终升级系统，模型仍然是必不可少的。 -  本章的目标是阐明系统建模中的关键问题，通常是形式验证，特别是模型检测。因为有这么多不同类型的系统和应用领域，有不同的关注点，甚至在形式化验证领域也有许多种建模语言、形式和工具以及建模技术、用途和方法。对这些进行彻底的说明超出了本章的范围；对这些语言或工具的描述可能需要一整本书。相反，这一章有三个更可描述的目标。首先，我们试图提供一个在为验证而建模系统时必须考虑的主要问题的概述。这些问题涉及建模语言的选择或设计以及模型创建的步骤。其次，我们介绍一种简单的建模语言，SML，说明选择或设计建模语言所涉及的问题。SML使用一种抽象的状态机形式，它基于转换系统表示捕获广泛使用的语言的关键特征，并且可以将手册中介绍或使用的建模语言绑定在一起。通过引入SML，我们还寻求简化从业者使用的真实语言(比如说，虚拟语言、Simulink或C语言)和模型检测中使用的各种底层形式(例如，自动机或克里普克结构)之间的联系。最后，本章通过从三个不同领域(硬件、软件和网络物理系统)提取的例证，展示了SML模型创建的关键步骤。 -  <h2>系统建模主要考虑的因素</h2> -  模型的建立有不同的原因。需要强调的是，模型主要是用于实现特定目的的工具。它们是达到目标的手段，而不是目标本身。因此，模型“好”或“坏”的概念本身没有什么意义。对于某个目标来说，检查一个模型是否好更合适。例如，模型对于估计系统的吞吐量可能是好的，但是对于检查系统是否有死锁是无用的，反之亦然。——所以对于一个模型，我们更要关注的是模型对于达成目标是否更有效果。 -  在选择一种好的建模形式和语言时，一般的形式验证，特别是模型检测通常要考虑以下几个主要因素: <li> <pre><code>  系统的类型:基于被建模系统的特性，已经开发了不同的建模形式。<br>  一些更常见的形式包括:<br>  </code></pre> </li><li> <pre><code>  所需建模的内容类型<br>  </code></pre> </li><li> <pre><code>  关于环境的相关信息<br>  </code></pre> </li><li> <pre><code>  抽象的层次<br>  </code></pre> </li><li> <pre><code>  清晰程度和模块化程度<br>  </code></pre> </li><li> <pre><code>  构成模型的形式<br>  </code></pre> </li><li> <pre><code>  计算引擎以及建模和表达的实际简易性<br>  </code></pre> </li><li></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%91%E7%A0%94/" rel="tag">科研</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-阅读Model Checking笔记手册 第二章 时序逻辑以及公平离散系统"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/06/01/%E9%98%85%E8%AF%BBModel%20Checking%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%8C%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F/"
    >阅读Model Checking笔记手册 第二章 时序逻辑以及公平离散系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/06/01/%E9%98%85%E8%AF%BBModel%20Checking%E7%AC%94%E8%AE%B0%E6%89%8B%E5%86%8C%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2021-06-01T13:06:09.000Z" itemprop="datePublished">2021-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>时序逻辑被哲学家用来推理世界随时间变化的方式。它在现代应用中被用来描述程序&#x2F;设计状态的演变，从而产生了对执行的描述。时序逻辑可以根据它们对时间演化的观点分为线性或分支。在线性时间视图中，我们看到时间范围是线性的并且是顺序的状态。当系统有多种可能的线性时序时(由于不确定性或读取输入)，我们将它们视为一个个独立的时序情况并且系统有一系列可能的行为。在分支时间视图中，一个时间点可能有多个可能的后继，因此呈现树状结构。根据这种观点，一个系统只有一个执行，它采取树的形式。我们从介绍公平离散结构来开始这一章，我们在这个模型上评估时态逻辑公式的真与假。公平离散结构描述了系统的状态及其可能的演化。然后我们从线性时间观点出发，引入命题线性时态逻辑。我们解释了<strong>安全性和活性属性</strong>之间的区别，并引入了一个增加表现力的活性属性层次。我们研究<strong>完整LTL的表达能力</strong>，并涵盖增加其表达能力的扩展。我们介绍了<strong>检查可满足性的算法和模型检查算法</strong>。我们转向分支时间框架并引入计算树逻辑。像以前一样，我们讨论它的表达能力，考虑扩展，并涵盖可满足性和模型检查。然后，我们花一些时间讨论LTL和CTL中的公式示例，并强调两者之间的差异。最后，我们对LTL和CTL进行了正式的比较，鉴于这种比较，我们引入了CTL*，它是LTL和CTL的混合，将线性视图和分支视图结合到一个逻辑中。</p>
<blockquote>
<p> 从时序逻辑LTL到CTL的发展中总结得到了模型检查的思想:模型检查是确定程序是否满足给定的时序逻辑规范的算法分析。 线性-分支二分法起源于关于选择自由和命运确定性的宗教辩论，导致了关于在验证中使用时间逻辑的意识形态辩论。各种研究比较了线性时间和分支时间方法，这也导致了CTL *的发明，一种结合线性时间逻辑和计算树逻辑的逻辑。 </p>
</blockquote>
<p>多年来，人们已经收集了关于时态逻辑及其在模型检测和验证中的使用的各个方面的广泛知识:哪些属性可以在哪种时态逻辑中表达，哪些属性不能在哪种时态逻辑中表达，怎样扩展逻辑的表达能力，以及不同问题的算法方面。特别是，有效的模型检测算法适用于大型系统，模型检测作为一项成功的技术广泛使用在工业界和学术界。</p>
<h2 id="2-2-Fair-Discrete-Systems——Kripke语义的介绍以及如何将它应用为表示程序的数学模型、并展示如何用公平离散系统来表示程序"><a href="#2-2-Fair-Discrete-Systems——Kripke语义的介绍以及如何将它应用为表示程序的数学模型、并展示如何用公平离散系统来表示程序" class="headerlink" title="2.2 Fair Discrete Systems——Kripke语义的介绍以及如何将它应用为表示程序的数学模型、并展示如何用公平离散系统来表示程序"></a>2.2 Fair Discrete Systems——Kripke语义的介绍以及如何将它应用为表示程序的数学模型、并展示如何用公平离散系统来表示程序</h2><p>为了能够形式化的推理系统和程序，我们必须就一个可以应用于推理的形式化数学模型。到目前为止，转换系统是计算机科学中表示程序的标准的工具。</p>
<blockquote>
 <p>转换系统在计算机科学中通常用作描述系统行为的模型，它是一种有向图，节点代表状态，边代表着状态的转化 状态（state）描述了系统在其行为的特定时刻的一些信息。 例如，交通灯的状态指示灯的当前颜色。类似地，顺序计算机程序的状态指示所有程序变量的当前值，以及指示要执行的下一个程序语句的程序计数器的当前值。 转变（transition）指定系统如何从一种状态演变为另一种状态。 对交通信号灯来说，转换表示从一种颜色切换到另一种颜色。而对于顺序程序，转换通常对应于语句的执行，并且可能涉及某些变量和程序计数器的更改。 下面给Transition System（TS）的定义 TS是一个六元组
</blockquote>
<p>​<br>​<br>​<br>         (</p>
<p>​<br>         S</p>
<p>​<br>         ,</p>
<p>​<br>​<br>          A</p>
<p>​<br>          c</p>
<p>​<br>          t</p>
<p>​<br>​<br>         ,</p>
<p>​<br>         →</p>
<p>​<br>         ,</p>
<p>​<br>​<br>          S</p>
<p>​<br>          0</p>
<p>​<br>​<br>         ,</p>
<p>​<br>​<br>          A</p>
<p>​<br>          P</p>
<p>​<br>​<br>         ,</p>
<p>​<br>         L</p>
<p>​<br>         )</p>
<p>​<br>​<br>        \left(\mathrm{S}, \mathrm{Act}, \rightarrow, S_{0}, \mathrm{AP}, \mathrm{L}\right)</p>
<p>​<br>     (S,Act,→,S0​,AP,L)：</p><br> <ul>- S是一组状态的集合- Act是一组动作的集合- →⊆S×Act×S是转换关系- S0⊆S是初始状态集，- AP是一组原子命题的集合<li></p>
<p>​<br>​<br>​<br>          L</p>
<p>​<br>          :</p>
<p>​<br>          S</p>
<p>​<br>          →</p>
<p>​<br>​<br>           2</p>
<p>​<br>​<br>            A</p>
<p>​<br>            P</p>
<p>​<br>​<br>​<br>​<br>         \mathrm{L}: \mathrm{S} \rightarrow 2^{A P}</p>
<p>​<br>      L:S→2AP是标识函数，标识在某个状态下为真的原子命题集</li><li>对比Kripke structure，我们可以发现TS有一个明显的不同，就是多了Act（动作）这个概念，如果状态s通过执行动作α发生状态的转变，转换到了状态s’，我们记为</p>
<p>​<br>​<br>​<br>          s</p>
<p>​<br>​<br>​<br>            ⟶</p>
<p>​<br>​<br>           α</p>
<p>​<br>​<br>​<br>           s</p>
<p>​<br>           ′</p>
<p>​<br>​<br>​<br>         s \stackrel{\alpha}{\longrightarrow} s^{\prime}</p>
<p>​<br>      s⟶α​s′</li>- 例子：<img src="https://img-blog.csdnimg.cn/20210517092857648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></ul> </p>
<p>在转换系统的基础上又定义了Kripke结构，这是建模中使用的最流行的转换系统版本之一。然后，我们提出了一个转换系统的符号化版本，我们称之为公平离散系统或简称为FDS（Fair Descrete System），其中状态作为变量的解释和转换出现，它对应于变量值的变化。 FDS简单解析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39110678/article/details/116993350">https://blog.csdn.net/qq_39110678/article/details/116993350</a></p>
<p>Representing Program Example：</p>
<pre><code>     D
</code></pre>
<p>​<br>         1</p>
<p>​<br>​<br>        &#x3D;</p>
<p>​<br>​<br>         ⟨</p>
<p>​<br>​<br>          {</p>
<p>​<br>​<br>           π</p>
<p>​<br>           1</p>
<p>​<br>​<br>          ,</p>
<p>​<br>          x</p>
<p>​<br>          ,</p>
<p>​<br>          y</p>
<p>​<br>          ,</p>
<p>​<br>          t</p>
<p>​<br>          }</p>
<p>​<br>​<br>         ,</p>
<p>​<br>​<br>          θ</p>
<p>​<br>          1</p>
<p>​<br>​<br>         ,</p>
<p>​<br>​<br>          ρ</p>
<p>​<br>          1</p>
<p>​<br>​<br>         ,</p>
<p>​<br>         J</p>
<p>​<br>         ,</p>
<p>​<br>         C</p>
<p>​<br>         ⟩</p>
<p>​<br>​<br>​<br>       \mathscr{D}<em>{1}&#x3D;\left\langle\left{\pi</em>{1}, x, y, t\right}, \theta_{1}, \rho_{1}, \mathscr{J}, \mathscr{C}\right\rangle</p>
<p>​<br>    D1​&#x3D;⟨{<!-- -->π1​,x,y,t},θ1​,ρ1​,J,C⟩ <img src="https://img-blog.csdnimg.cn/20210520133226740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 以下状态序列是上图中简单循环的运行 Example2：</p>
<p>​<br>​<br>​<br>        D</p>
<p>​<br>        2</p>
<p>​<br>        &#x3D;</p>
<p>​<br>​<br>         ⟨</p>
<p>​<br>​<br>          {</p>
<p>​<br>​<br>           π</p>
<p>​<br>           2</p>
<p>​<br>​<br>          ,</p>
<p>​<br>          x</p>
<p>​<br>          ,</p>
<p>​<br>          y</p>
<p>​<br>          ,</p>
<p>​<br>          t</p>
<p>​<br>          }</p>
<p>​<br>​<br>         ,</p>
<p>​<br>​<br>          θ</p>
<p>​<br>          2</p>
<p>​<br>​<br>         ,</p>
<p>​<br>​<br>          ρ</p>
<p>​<br>          2</p>
<p>​<br>​<br>         ,</p>
<p>​<br>         J</p>
<p>​<br>         ,</p>
<p>​<br>         C</p>
<p>​<br>         ⟩</p>
<p>​<br>​<br>​<br>       D2&#x3D;\left\langle\left{\pi_{2}, x, y, t\right}, \theta_{2}, \rho_{2}, \mathscr{J}, \mathscr{C}\right\rangle</p>
<p>​<br>    D2&#x3D;⟨{<!-- -->π2​,x,y,t},θ2​,ρ2​,J,C⟩ <img src="https://img-blog.csdnimg.cn/2021052309263861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTEwNjc4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> Example3: </p>
<p>​<br>​<br>​<br>        T</p>
<p>​<br>        &#x3D;</p>
<p>​<br>​<br>         ⟨</p>
<p>​<br>         {</p>
<p>​<br>         t</p>
<p>​<br>         }</p>
<p>​<br>         ,</p>
<p>​<br>         t</p>
<p>​<br>         &#x3D;</p>
<p>​<br>         0</p>
<p>​<br>         ,</p>
<p>​<br>         t</p>
<p>​<br>         &#x3D;</p>
<p>​<br>​<br>          t</p>
<p>​<br>          ′</p>
<p>​<br>​<br>​<br>        ∅</p>
<p>​<br>        ,</p>
<p>​<br>        ∅</p>
<p>​<br>        ⟩</p>
<p>​<br>        .</p>
<p>​<br>​<br>       T&#x3D;\left\langle{t}, t&#x3D;0, t&#x3D;t^{\prime}\right.\emptyset, \emptyset\rangle .</p>
<p>​<br>    T&#x3D;⟨{<!-- -->t},t&#x3D;0,t&#x3D;t′∅,∅⟩. 注：</p>
<p>​<br>​<br>​<br>        keep</p>
<p>​<br>        ⁡</p>
<p>​<br>​<br>         (</p>
<p>​<br>​<br>          π</p>
<p>​<br>          1</p>
<p>​<br>​<br>         ,</p>
<p>​<br>         x</p>
<p>​<br>         ,</p>
<p>​<br>         y</p>
<p>​<br>         ,</p>
<p>​<br>         t</p>
<p>​<br>         )</p>
<p>​<br>​<br>​<br>       \operatorname{keep}\left(\pi_{1}, x, y, t\right)</p>
<p>​<br>    keep(π1​,x,y,t)代表这四个变量可以有部分变量不出现。</p>
<p>​<br>​<br>​<br>​<br>        D</p>
<p>​<br>        &#x3D;</p>
<p>​<br>​<br>         D</p>
<p>​<br>         1</p>
<p>​<br>​<br>​<br>         ∥</p>
<p>​<br>​<br>          D</p>
<p>​<br>          2</p>
<p>​<br>​<br>         ∥</p>
<p>​<br>​<br>        T</p>
<p>​<br>​<br>       \mathscr{D}&#x3D;\mathscr{D}<em>{1}\left|\mathscr{D}</em>{2}\right| \mathscr{T}</p>
<p>​<br>    D&#x3D;D1​∥D2​∥T D构成了一个FDS，这个系统就是皮特森互斥算法。 Var </p>
<p>​<br>​<br>​<br>        t</p>
<p>​<br>        ,</p>
<p>​<br>        x</p>
<p>​<br>        ,</p>
<p>​<br>        y</p>
<p>​<br>        :</p>
<p>​<br>​<br>       t, x, y:</p>
<p>​<br>    t,x,y: Boolean initially </p>
<p>​<br>​<br>​<br>        t</p>
<p>​<br>        &#x3D;</p>
<p>​<br>        0</p>
<p>​<br>        ,</p>
<p>​<br>        x</p>
<p>​<br>        &#x3D;</p>
<p>​<br>        0</p>
<p>​<br>        ,</p>
<p>​<br>​<br>        y</p>
<p>​<br>        &#x3D;</p>
<p>​<br>        0</p>
<p>​<br>​<br>       t&#x3D;0, x&#x3D;0, \quad y&#x3D;0</p>
<p>​<br>    t&#x3D;0,x&#x3D;0,y&#x3D;0 </p>
<p>​<br>​<br>​<br>​<br>         [</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               0</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               while (true) </p>
<p>​<br>              {</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               1</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               Non Critical </p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               2</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              x</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              1</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               3</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              t</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              1</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               4</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               await </p>
<p>​<br>              (</p>
<p>​<br>              t</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              0</p>
<p>​<br>              ∨</p>
<p>​<br>              y</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              0</p>
<p>​<br>              )</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               5</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               Critical </p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               6</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              x</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              0</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               l</p>
<p>​<br>               7</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>         ]</p>
<p>​<br>​<br>        ∥</p>
<p>​<br>​<br>         [</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               m</p>
<p>​<br>               0</p>
<p>​<br>​<br>              :</p>
<p>​<br>               while (true) </p>
<p>​<br>              {</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               m</p>
<p>​<br>               1</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>              Non Critical; </p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               m</p>
<p>​<br>               2</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              y</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              1</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               m</p>
<p>​<br>               3</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              t</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              0</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               m</p>
<p>​<br>               4</p>
<p>​<br>​<br>              :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>               await </p>
<p>​<br>              (</p>
<p>​<br>              t</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              1</p>
<p>​<br>              ∨</p>
<p>​<br>              x</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              0</p>
<p>​<br>              )</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              m</p>
<p>​<br>              5</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              :</p>
<p>​<br>​<br>               Critical </p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              m</p>
<p>​<br>              6</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>             :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>              y</p>
<p>​<br>              &#x3D;</p>
<p>​<br>              0</p>
<p>​<br>              ;</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>              m</p>
<p>​<br>              7</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>             :</p>
<p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>         ]</p>
<p>​<br>​<br>​<br>       \left[\begin{array}{ll}l_{0}: &amp; \text { while (true) }{ \ l_{1}: &amp; \text { Non Critical } ; \ l_{2}: &amp; x&#x3D;1 ; \ l_{3}: &amp; t&#x3D;1 ; \ l_{4}: &amp; \text { await }(t&#x3D;&#x3D;0 \vee y&#x3D;&#x3D;0) ; \ l_{5}: &amp; \text { Critical } ; \ l_{6}: &amp; x&#x3D;0 ; \ l_{7}: &amp; \end{array}\right] |\left[\begin{array}{l}m_{0}: \text { while (true) }{ \ m_{1}: &amp; \text { Non Critical; } \ m_{2}: &amp; y&#x3D;1 ; \ m_{3}: &amp; t&#x3D;0 ; \ m_{4}: &amp; \text { await }(t&#x3D;&#x3D;1 \vee x&#x3D;&#x3D;0) ; \ m_{5} &amp; : \quad \text { Critical } ; \ m_{6} &amp; : &amp; y&#x3D;0 ; \ m_{7} &amp; : &amp; \end{array}\right]</p>
<p>​<br>    ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​l0​:l1​:l2​:l3​:l4​:l5​:l6​:l7​:​ while (true) {<!-- --> Non Critical ;x&#x3D;1;t&#x3D;1; await (t&#x3D;&#x3D;0∨y&#x3D;&#x3D;0); Critical ;x&#x3D;0;​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​∥⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​m0​: while (true) {<!-- -->m1​:m2​:m3​:m4​:m5​m6​m7​​ Non Critical; y&#x3D;1;t&#x3D;0; await (t&#x3D;&#x3D;1∨x&#x3D;&#x3D;0);: Critical ;::​y&#x3D;0;​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%91%E7%A0%94/" rel="tag">科研</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Yangzewei
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/256love.ico" alt="Y&amp;&amp;S"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photo/">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=22707008&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>